package mipsAsm.assembler.operand;

import java.util.HashMap;

import mipsAsm.assembler.Assembler;
import mipsAsm.assembler.exception.AsmError;
import mipsAsm.assembler.util.AsmWarning;

/**
 * The base class for all types of operands.
 * 
 * @author YunYe Pu
 */
public abstract class Operand
{
	/**
	 * @return The binary encoding of the operand field.
	 */
	public abstract int getEncoding();
	
	/**
	 * Set the width of the operand field, in bits. Warnings are allowed to be generated by returning
	 * an instance of {@link AsmWarning}; this warning will then be handled by an instance of {@link Assembler}.
	 * The reason for not using exception for warning handling is to avoid interfering normal execution of assembly.
	 * 
	 * @param width The maximum width in bits for the value returned by {@link Operand#getEncoding} method.
	 * @return An instance of AsmWarning if necessary, or null if no need to generate a warning.
	 */
	public abstract AsmWarning setWidth(int width);
	
	private static final HashMap<Class<? extends Operand>, String> opTypeNameMap = new HashMap<>();

	static
	{
		opTypeNameMap.put(OpLabel.class, "label");
		opTypeNameMap.put(OpRegister.class, "register");
		opTypeNameMap.put(OpConstant.class, "constant");
		opTypeNameMap.put(OpImmediate.class, "immediate");
		opTypeNameMap.put(OpString.class, "string");
	}

	public static String getTypeName(Class<? extends Operand> type)
	{
		return opTypeNameMap.get(type);
	}
	
	public static String getTypeName(Operand obj)
	{
		return opTypeNameMap.get(obj.getClass());
	}
	
	public static Operand parse(String token, Assembler assembler) throws AsmError
	{
		if(token.matches(OpRegister.format))
			return OpRegister.newInstance(token, assembler);
		else if(token.matches(OpImmediate.format))
			return new OpImmediate(token);
		else if(token.matches(OpLabel.format))
			return new OpLabel(token);
		else if(token.matches(OpString.format))
			return new OpString(token);
		else
			throw new AsmError("Unrecognizable token", "Unable to parse token \"" + token + "\" as an argument.");
	}
}
